'use strict';

const fs = require('fs').promises;
const path = require('path');

const debug = require('debug')('WireGuard');
const uuid = require('uuid');
const QRCode = require('qrcode');

const Util = require('./Util');
const ServerError = require('./ServerError');

const {
  WG_PATH,
  WG_HOST,
  WG_PORT,
  WG_MTU,
  WG_DEFAULT_DNS,
  WG_DISABLE_ADDRESS_IPV4,
  WG_DEFAULT_ADDRESS_IPV4,
  WG_DEFAULT_ADDRESS_IPV6,
  WG_PERSISTENT_KEEPALIVE,
  WG_ALLOWED_IPS,
  WG_PRE_UP,
  WG_POST_UP,
  WG_PRE_DOWN,
  WG_POST_DOWN,
} = require('../config');

module.exports = class WireGuard {

  async getConfig() {
    if (!this.__configPromise) {
      this.__configPromise = Promise.resolve().then(async () => {
        if (!WG_HOST) {
          throw new Error('WG_HOST Environment Variable Not Set!');
        }

        debug('Loading configuration...');
        let config;
        try {
          config = await fs.readFile(path.join(WG_PATH, 'wg0.json'), 'utf8');
          config = JSON.parse(config);
          debug('Configuration loaded.');
        } catch (err) {
          const privateKey = await Util.exec('wg genkey');
          const publicKey = await Util.exec(`echo ${privateKey} | wg pubkey`, {
            log: 'echo ***hidden*** | wg pubkey',
          });
          const addressIPv4 = WG_DEFAULT_ADDRESS_IPV4.replace('x', '1');
          const addressIPv6 = WG_DEFAULT_ADDRESS_IPV6.replace('x', '1');

          config = {
            server: {
              privateKey,
              publicKey,
              addressIPv4,
              addressIPv6,
            },
            clients: {},
          };
          debug('Configuration generated.');
        }

        await this.__saveConfig(config);
        await Util.exec('wg-quick down wg0').catch(() => { });
        await Util.exec('wg-quick up wg0').catch(err => {
          if (err && err.message && err.message.includes('Cannot find device "wg0"')) {
            throw new Error('WireGuard exited with the error: Cannot find device "wg0"\nThis usually means that your host\'s kernel does not support WireGuard!');
          }

          throw err;
        });
        await this.__syncConfig();

        return config;
      });
    }

    return this.__configPromise;
  }

  async saveConfig(ifPublicKeyExists) {
    const config = await this.getConfig();
    await this.__saveConfig(config, ifPublicKeyExists);
    await this.__syncConfig();
  }

  async __saveConfig(config, ifPublicKeyExists) {
    let serverIPAddress = `${config.server.addressIPv4}, ${config.server.addressIPv6}`;
    // eslint-disable-next-line no-console
    console.log(WG_DISABLE_ADDRESS_IPV4);
    if (WG_DISABLE_ADDRESS_IPV4) {
      serverIPAddress = `${config.server.addressIPv6}`;
    }

    let result = `
# Note: Do not edit this file directly.
# Your changes will be overwritten!

# Server
[Interface]
PrivateKey = ${config.server.privateKey}
Address = ${serverIPAddress}
ListenPort = 51820
PreUp = ${WG_PRE_UP}
PostUp = ${WG_POST_UP}
PreDown = ${WG_PRE_DOWN}
PostDown = ${WG_POST_DOWN}
`;

    for (const [clientId, client] of Object.entries(config.clients)) {
      if (!client.enabled) continue;

      let clientIpAddess = `${client.addressIPv4}, ${client.addressIPv6}`;
      if (WG_DISABLE_ADDRESS_IPV4) {
        clientIpAddess = `${client.addressIPv6}`;
      }

      if (ifPublicKeyExists) {
        result += `
# Client: ${client.name} (${clientId})
[Peer]
PublicKey = ${client.publicKey}
AllowedIPs = ${clientIpAddess}`;
      } else {
        result += `

# Client: ${client.name} (${clientId})
[Peer]
PublicKey = ${client.publicKey}
PresharedKey = ${client.preSharedKey}
AllowedIPs = ${clientIpAddess}`;
      }
    }

    debug('Config saving...');
    await fs.writeFile(path.join(WG_PATH, 'wg0.json'), JSON.stringify(config, false, 2), {
      mode: 0o660,
    });
    await fs.writeFile(path.join(WG_PATH, 'wg0.conf'), result, {
      mode: 0o600,
    });
    debug('Config saved.');
  }

  async __syncConfig() {
    debug('Config syncing...');
    await Util.exec('wg syncconf wg0 <(wg-quick strip wg0)');
    debug('Config synced.');
  }

  async getClients() {
    const config = await this.getConfig();
    const clients = Object.entries(config.clients).map(([clientId, client]) => ({
      id: clientId,
      name: client.name,
      enabled: client.enabled,
      addressIPv4: client.addressIPv4,
      addressIPv6: client.addressIPv6,
      publicKey: client.publicKey,
      createdAt: new Date(client.createdAt),
      updatedAt: new Date(client.updatedAt),
      allowedIPs: client.allowedIPs,
      persistentKeepalive: null,
      latestHandshakeAt: null,
      transferRx: null,
      transferTx: null,
    }));

    // Loop WireGuard status
    const dump = await Util.exec('wg show wg0 dump', {
      log: false,
    });
    dump
      .trim()
      .split('\n')
      .slice(1)
      .forEach(line => {
        const [
          publicKey,
          preSharedKey, // eslint-disable-line no-unused-vars
          endpoint, // eslint-disable-line no-unused-vars
          allowedIps, // eslint-disable-line no-unused-vars
          latestHandshakeAt,
          transferRx,
          transferTx,
          persistentKeepalive,
        ] = line.split('\t');

        const client = clients.find(client => client.publicKey === publicKey);
        if (!client) return;

        client.latestHandshakeAt = latestHandshakeAt === '0'
          ? null
          : new Date(Number(`${latestHandshakeAt}000`));
        client.transferRx = Number(transferRx);
        client.transferTx = Number(transferTx);
        client.persistentKeepalive = persistentKeepalive;
      });

    return clients;
  }

  async getClient({ clientId }) {
    const config = await this.getConfig();
    const client = config.clients[clientId];
    if (!client) {
      throw new ServerError(`Client Not Found: ${clientId}`, 404);
    }

    return client;
  }

  async getClientData({ clientId }) {
    const config = await this.getConfig();
    const client = config.clients[clientId];
    if (!client) {
      throw new ServerError(`Client Not Found: ${clientId}`, 404);
    }

    return client;
  }

  async getClientConfiguration({ clientId }) {
    const config = await this.getConfig();
    const client = await this.getClient({ clientId });

    return `
[Interface]
PrivateKey = ${client.privateKey}
Address = ${client.addressIPv4}, ${client.addressIPv6}
${WG_DEFAULT_DNS ? `DNS = ${WG_DEFAULT_DNS}` : ''}
${WG_MTU ? `MTU = ${WG_MTU}` : ''}

[Peer]
PublicKey = ${config.server.publicKey}
PresharedKey = ${client.preSharedKey}
AllowedIPs = ${WG_ALLOWED_IPS}
PersistentKeepalive = ${WG_PERSISTENT_KEEPALIVE}
Endpoint = ${WG_HOST}:${WG_PORT}`;
  }

  async getClientQRCodeSVG({ clientId }) {
    const config = await this.getClientConfiguration({ clientId });
    return QRCode.toString(config, {
      type: 'svg',
      width: 512,
    });
  }

  async createClient({ name, publicKey = null, allowedIp }) {
    if (!name) {
      throw new Error('Missing: Name');
    }

    const config = await this.getConfig();

    let ifPublicKeyExists = true;
    let addressIPv4;
    let addressIPv6;
    let privateKey;
    let preSharedKey;
    let receivedPubKey;
    let client = {};

    if (!publicKey) {
      ifPublicKeyExists = false;

      privateKey = await Util.exec('wg genkey');

      publicKey = await Util.exec(`echo ${privateKey} | wg pubkey`);
      preSharedKey = await Util.exec('wg genpsk');

      // Calculate next IPv4

      for (let i = 2; i < 255; i++) {
        const client = Object.values(config.clients).find(client => {
          return client.addressIPv4 === WG_DEFAULT_ADDRESS_IPV4.replace('x', i);
        });

        if (!client) {
          addressIPv4 = WG_DEFAULT_ADDRESS_IPV4.replace('x', i);
          break;
        }
      }

      if (!addressIPv4) {
        throw new Error('Maximum number of clients reached.');
      }

      // Calculate next IPv6

      for (let i = 2; i < 255; i++) {
        const client = Object.values(config.clients).find(client => {
          return client.addressIPv6 === WG_DEFAULT_ADDRESS_IPV6.replace('x', i);
        });

        if (!client) {
          addressIPv6 = WG_DEFAULT_ADDRESS_IPV6.replace('x', i);
          break;
        }
      }

      if (!addressIPv6) {
        throw new Error('Maximum number of clients reached.');
      }
    } else {
      receivedPubKey = publicKey;
      client.publicKey = receivedPubKey;
      client.addressIPv6 = allowedIp;
    }

    // Create Client
    const clientId = uuid.v4();
    client = {
      clientId,
      name,
      addressIPv4,
      addressIPv6,
      privateKey,
      publicKey,
      preSharedKey,

      createdAt: new Date(),
      updatedAt: new Date(),

      enabled: true,
      ...client,
    };

    config.clients[clientId] = client;

    await this.saveConfig(ifPublicKeyExists);

    return client;
  }

  async deleteClient({ clientId }) {
    const config = await this.getConfig();

    if (config.clients[clientId]) {
      delete config.clients[clientId];
      await this.saveConfig();
    }
  }

  async enableClient({ clientId }) {
    const client = await this.getClient({ clientId });

    client.enabled = true;
    client.updatedAt = new Date();

    await this.saveConfig();
  }

  async disableClient({ clientId }) {
    const client = await this.getClient({ clientId });

    client.enabled = false;
    client.updatedAt = new Date();

    await this.saveConfig();
  }

  async updateClientName({ clientId, name }) {
    const client = await this.getClient({ clientId });

    client.name = name;
    client.updatedAt = new Date();

    await this.saveConfig();
  }

  async updateClientPublicKey({ clientId, publicKey }) {
    const client = await this.getClient({ clientId });
    const ifPublicKeyExists = !!publicKey;
    client.publicKey = publicKey;
    client.updatedAt = new Date();
    // send public key
    await this.saveConfig(ifPublicKeyExists);
  }

  async updateClientAddressIPv4({ clientId, addressIPv4 }) {
    const client = await this.getClient({ clientId });

    if (!Util.isValidIPv4(addressIPv4)) {
      throw new ServerError(`Invalid Address: ${addressIPv4}`, 400);
    }

    client.addressIPv4 = addressIPv4;
    client.updatedAt = new Date();

    await this.saveConfig();
  }

  async updateClientAddressIPv6({ clientId, addressIPv6 }) {
    const client = await this.getClient({ clientId });

    if (!Util.isValidIPv4(addressIPv6)) {
      throw new ServerError(`Invalid Address: ${addressIPv6}`, 400);
    }

    client.addressIPv6 = addressIPv6;
    client.updatedAt = new Date();

    await this.saveConfig();
  }

};
